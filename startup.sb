let rhythms_string = [
  #shiko
  "1 ~ ~ ~ 1 ~ 1 ~ ~ ~ 1 ~ 1 ~ ~ ~",
  #son
  "1 ~ ~ 1 ~ ~ 1 ~ ~ ~ 1 ~ 1 ~ ~ ~",
  #rumba
  "1 ~ ~ 1 ~ ~ ~ 1 ~ ~ 1 ~ 1 ~ ~ ~",
  #soukous
  "1 ~ ~ 1 ~ ~ 1 ~ ~ ~ 1 1 ~ ~ ~ ~",
  #gahu
  "1 ~ ~ 1 ~ ~ 1 ~ ~ ~ 1 ~ ~ ~ 1 ~",
  #bossa-nova
  "1 ~ ~ 1 ~ ~ 1 ~ ~ ~ 1 ~ ~ 1 ~ ~"
]

let rhythms_int = [
  #shiko
  [1, ~, ~, ~, 1, ~, 1, ~, ~, ~, 1, ~, 1, ~, ~, ~],
  #son
  [1, ~, ~, 1, ~, ~, 1, ~, ~, ~, 1, ~, 1, ~, ~, ~],
  #rumba
  [1, ~, ~, 1, ~, ~, ~, 1, ~, ~, 1, ~, 1, ~, ~, ~],
  #soukous
  [1, ~, ~, 1, ~, ~, 1, ~, ~, ~, 1, 1, ~, ~, ~, ~],
  #gahu
  [1, ~, ~, 1, ~, ~, 1, ~, ~, ~, 1, ~, ~, ~, 1, ~],
  #bossa-nova
  [1, ~, ~, 1, ~, ~, 1, ~, ~, ~, 1, ~, ~, 1, ~, ~]
]

let distrhythms_string = gen()
{
  setup() {}

  run() {
    let idx = rand(len(rhythms_string))
      #puts("IDX is ", idx, " - pattern is: ", rhythms_string[idx])
      return rhythms_string[idx]
  }
}

let riff = fn(root)
{
  let valid_notes = notes_in_key(root);
  #print("VALLEYNOTES:", valid_notes);
  let beat = bjork(rand(9) + 2, 16);
  for ( i = 0; i < 16; ++i) {
    if (beat[i] == 1) {
      let multi = rand(3) + 2;
      beat[i] = valid_notes[rand(len(valid_notes))] + 12*multi;
    }
  }
  return beat;
}

let map = fn(arrray, fooonction)
{
  let mapduh = [];
  for (i = 0; i < len(arrray); ++i)
  {
    if (arrray[i] ) {
      mapduh = push(mapduh, fooonction(arrray[i]));
    } else {
      mapduh = push(mapduh, ~);
    }
  }
  return mapduh;
}

let rand_beat = gen()
{
  setup() {}

  run() {
    let idx = rand(len(rhythms_int))
      #puts("IDX is ", idx, " - pattern is: ", rhythms_int[idx])
      return rhythms_int[idx]
  }
}

let count = 0;

let countr = gen()
{
  setup() {}
  run()
  {
    ++count;
  }
}

p0 # countr ;

# i.e. 3840 / 16 == 240 midi Pulses Per 16th
let pp = 240;

let up = fn(array_val, octaves)
{
  return map(array_val, fn(v) { if (v > 0) { return v + 12*octaves; } else { return v;}  });
}

let down = fn(array_val, octaves)
{
  return map(array_val, fn(v) { if (v > 0) { return v - 12*octaves; } else { return v;}  });
}

let combinor = fn(rhythm, melody)
{
  let return_melody= [];
  for (i=0; i < len(rhythm); ++i)
  {
    if (rhythm[i] > 0) {
      return_melody = push(return_melody, melody[mel_idx]);
      mel_idx = incr(mel_idx, 0, len(melody));
    } else {
      return_melody = push(return_melody, 0);
    }
  }
  return return_melody;
}

