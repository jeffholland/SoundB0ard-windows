let shiko = [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0];
let son = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0];
let rumba = [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0];
let soukous = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0];
let gahu = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0];
let bossa = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0];

let rhythms_int = [ shiko, son, rumba, soukous, gahu, bossa ];

let briff = fn(root)
{
  #print("VALLEYNOTES:", valid_notes);
  let beat = bjork(rand(9) + 2, 16);
  #let beat = rand_array(16, 0, 1);
  for ( i = 0; i < 16; ++i) {
    if (beat[i] == 1) {
      beat[i] = root;
    }
  }
  return beat;
}


let riff = fn(root)
{
  #print("VALLEYNOTES:", valid_notes);
  let beat = bjork(rand(9) + 2, 16);
  #let beat = rand_array(16, 0, 1);
  for ( i = 0; i < 16; ++i) {
    if (beat[i] == 1) {
      beat[i] = root;
    }
  }
  return beat;
}

let key_riff = fn(root)
{
  let valid_notes = notes_in_key(root);
  #print("VALLEYNOTES:", valid_notes);
  let beat = bjork(rand(9) + 2, 16);
  #let beat = rand_array(16, 0, 1);
  for ( i = 0; i < 16; ++i) {
    if (beat[i] == 1) {
      beat[i] = valid_notes[rand(len(valid_notes))];
    }
  }
  return beat;
}

let chord_riff = fn(notes)
{
  #print("VALLEYNOTES:", valid_notes);
  let beat = bjork(rand(9) + 2, 16);
  #let beat = rand_array(16, 0, 1);
  for ( i = 0; i < 16; ++i) {
    if (beat[i] == 1) {
      beat[i] = notes[rand(len(notes))];
    }
  }
  return beat;
}

let map = fn(arrray, fooonction)
{
  let mapduh = [];
  for (i = 0; i < len(arrray); ++i)
  {
    if (arrray[i] ) {
      mapduh = push(mapduh, fooonction(arrray[i]));
    } else {
      mapduh = push(mapduh, ~);
    }
  }
  return mapduh;
}

let rand_beat = gen()
{
  setup() {}

  run() {
    let idx = rand(len(rhythms_int))
      #puts("IDX is ", idx, " - pattern is: ", rhythms_int[idx])
      return rhythms_int[idx]
  }
}

let count = 0;

let countr = gen()
{
  setup() {}
  run()
  {
    ++count;
  }
}

p0 # countr ;

# i.e. 3840 / 16 == 240 midi Pulses Per 16th
let pp = 240;

let up = fn(array_val, octaves)
{
  return map(array_val, fn(v) { if (v > 0) { return v + 12*octaves; } else { return v;}  });
}

let down = fn(array_val, octaves)
{
  return map(array_val, fn(v) { if (v > 0) { return v - 12*octaves; } else { return v;}  });
}

let combinorCh = fn(rhythm, chord)
{
  let return_melody= [];
  for (i=0; i < len(rhythm); ++i)
  {
    if (type(rhythm[i]) == "ARRAY") {
      return_melody = push(return_melody, combinorCh(rhythm[i], melody));
    }
    else {
      if (rhythm[i] > 0) {
        return_melody = push(return_melody, chord);
      } else {
        return_melody = push(return_melody, 0);
      }
    }
  }
  return return_melody;
}


let combinor = fn(rhythm, melody)
{
  let return_melody= [];
  let mel_idx = 0;
  for (i=0; i < len(rhythm); ++i)
  {
    if (type(rhythm[i]) == "ARRAY") {
      return_melody = push(return_melody, combinor(rhythm[i], melody));
    }
    else {
      if (rhythm[i] > 0) {
        return_melody = push(return_melody, melody[mel_idx]);
        mel_idx = incr(mel_idx, 0, len(melody));
      } else {
        return_melody = push(return_melody, 0);
      }
    }
  }
  return return_melody;
}

let phasefn = fn(soundgen1, soundgen2, pat_array, sg2_px, carry, bars_to_phase_over, note_dur)
{
  let pp = 3840 / len(pat_array);
  let qpp = (3840* bars_to_phase_over) / (len(pat_array) * bars_to_phase_over + 1);

  # normal time
  for (i = 0; i < len(pat_array); ++i) {
    #print("sg:", soundgen1, "I:", pat_array[i], " dru:" ,note_dur, " pp:", pp);
    note_on_at(soundgen1, pat_array[i], i * pp, dur=note_dur);
  }

  # phased time
  for (i = 0; i < len(pat_array); ++i ) {
    let time_at = i * qpp + carry;
    note_on_at(soundgen2, pat_array[sg2_px], time_at, dur=note_dur);
    sg2_px = incr(sg2_px, 0, len(pat_array));
  }
  let last_idx = (len(pat_array) * qpp) + carry;
  if (last_idx < 3840) {
    note_on_at(soundgen2, pat_array[sg2_px], last_idx, dur=note_dur);
    sg2_px = incr(sg2_px, 0, len(pat_array));
    let diff = 3840 - last_idx;
    carry = qpp - diff;
  } else {
    carry = last_idx - 3840;
  }
  return [sg2_px, carry];
}

let map_to_array = fn(the_map, len_array)
{
  let the_array = [];

  for (i = 0; i < len_array; ++i) {
    if (type(the_map[i]) == "NUMBER") {
      push(the_array, the_map[i]);
    } else {
      push(the_array, 0);
    }
  }
  return the_array;
}

let is_val_in_list = fn(the_list, the_val)
{
  for (i = 0; i < len(the_list); ++i) {
    if (the_list[i] == the_val) {
      return true;
    }
  }
  return false;
}

let list_to_array = fn(the_list, len_array)
{
  let the_array = [];
  for (i = 0; i < len_array; ++i) {
    if (is_val_in_list(the_list, i)){
      the_array = push(the_array, 1);
    } else {
      the_array = push(the_array, 0);
    }
  }
  return the_array;
}

let double = fn(list)
{
  let return_valz = list_to_array([], 16);
  if (len(list) == 16) {
    for (i = 0; i < 16; ++i) {
      if (list[i] > 0) {
        return_valz[i/2] = list[i];
        return_valz[8 + i/2] = list[i];
      }
    }
  }
  return return_valz;
}

let play_pattern = fn(sg, pat)
{
  let lenny = len(pat);
  let pp = 3840 / lenny;

  for (i = 0; i < lenny; ++i) {
    if (type(pat[i]) == "ARRAY" || (type(pat[i]) == "NUMBER" && pat[i] > 0)) {
      note_on_at(sg, pat[i], pp * i);
    }
  }
}

let gen_beat = fn()
{
  let beat = bjork(rand(5)+2, 16);
  if (rand(100) > 70) {
    beat = rand_beat();
  }

  for (i = 4; i < 16; ++i) {
    if (beat[i] == 1 && rand(100) > 60) {
      beat[i] = bjork(rand(3)+1, 8);
    }
  }

  for (i = 8; i < 16; ++i) {
    if (beat[i] == 1 && rand(100) > 80) {
      beat[i] = bjork(rand(4)+1, 8);
    }
  }

  return beat;
}
